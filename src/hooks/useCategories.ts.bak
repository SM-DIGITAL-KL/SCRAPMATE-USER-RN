/**
 * React Query hooks for categories and subcategories management
 */

import { useApiQuery, useApiMutation } from './index';
import { queryClient } from '../services/api/queryClient';
import { 
  getCategories, 
  getSubcategories, 
  getCategoriesWithSubcategories,
  getIncrementalUpdates,
  Category,
  Subcategory,
  CategoriesResponse,
  SubcategoriesResponse,
} from '../services/api/v2/categories';
import {
  getCachedCategories,
  saveCachedCategories,
  getLastUpdatedOn,
  updateLastUpdatedOn,
  mergeIncrementalUpdates,
  isCacheValid,
} from '../services/cache/categoriesCache';
import { 
  getUserCategories, 
  getUserSubcategories,
  updateUserCategories,
  updateUserSubcategories,
  removeUserCategory,
  removeUserSubcategories,
} from '../services/api/v2/profile';
import { queryKeys } from '../services/api/queryKeys';

/**
 * Hook to get all categories
 */
export const useCategories = (userType?: 'b2b' | 'b2c' | 'all', enabled = true) => {
  return useApiQuery<CategoriesResponse>({
    queryKey: queryKeys.categories.byUserType(userType),
    queryFn: () => getCategories(userType),
    enabled,
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
  });
};

/**
 * Hook to get subcategories
 */
export const useSubcategories = (
  categoryId?: number,
  userType?: 'b2b' | 'b2c' | 'all',
  enabled = true
) => {
  return useApiQuery<SubcategoriesResponse>({
    queryKey: queryKeys.subcategories.byCategory(categoryId || 0, userType),
    queryFn: () => getSubcategories(categoryId, userType),
    enabled: enabled && !!categoryId,
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  });
};

/**
 * Hook to get categories with subcategories
 * Uses 365-day persistent cache with incremental updates via AsyncStorage
 */
export const useCategoriesWithSubcategories = (
  userType?: 'b2b' | 'b2c' | 'all',
  enabled = true
) => {
  return useApiQuery({
    queryKey: [...queryKeys.categories.all, 'withSubcategories', userType || 'all'],
    // Disable structural sharing to ensure React Query detects all changes
    // This ensures that when we update the cache with incremental updates, React Query sees it as a new value
    structuralSharing: false,
    queryFn: async () => {
      // Check AsyncStorage cache first (365-day persistence)
      const cachedData = await getCachedCategories();
      const lastUpdatedOn = await getLastUpdatedOn();
      const cacheIsValid = await isCacheValid();

      if (cachedData && cacheIsValid && lastUpdatedOn) {
        // Try to get incremental updates in background
        try {
          console.log('ðŸ”„ [useCategories] Fetching incremental updates...');
          console.log(`   userType: ${userType}`);
          console.log(`   lastUpdatedOn: ${lastUpdatedOn}`);
          
          const updates = await getIncrementalUpdates(userType, lastUpdatedOn);
          
          console.log('ðŸ“¥ [useCategories] Incremental updates received:');
          console.log(`   hasUpdates: ${updates.meta?.hasUpdates}`);
          console.log(`   categories_count: ${updates.data?.categories?.length || 0}`);
          console.log(`   subcategories_count: ${updates.data?.subcategories?.length || 0}`);
          
          if (updates.meta.hasUpdates) {
            // Log category names before merge
            const categoryNamesBefore = cachedData.map(c => `${c.id}:${c.name}`).join(', ');
            console.log(`   ðŸ“‹ Categories before merge: ${categoryNamesBefore}`);
            
            // Merge incremental updates with cached data
            const mergedData = mergeIncrementalUpdates(cachedData, updates.data);
            
            // Log category names after merge
            const categoryNamesAfter = mergedData.map(c => `${c.id}:${c.name}`).join(', ');
            console.log(`   ðŸ“‹ Categories after merge: ${categoryNamesAfter}`);
            
            // Save updated cache to AsyncStorage (365-day persistence)
            await saveCachedCategories(mergedData, updates.meta.lastUpdatedOn);
            
            // Create a new merged response with new object references
            // This ensures React Query detects the change and triggers a re-render
            // We create new object references for all nested data to ensure React Query sees it as changed
            const updatedResponse = {
              status: 'success' as const,
              msg: 'Categories with subcategories retrieved successfully (incremental update)',
              data: mergedData.map(cat => ({
                ...cat,
                // Ensure subcategories array is also a new reference
                subcategories: cat.subcategories ? cat.subcategories.map(sub => ({ ...sub })) : [],
              })),
              meta: {
                total_categories: mergedData.length,
                total_subcategories: mergedData.reduce((sum, cat) => sum + (cat.subcategory_count || 0), 0),
                b2b_available: mergedData.filter(c => c.available_in?.b2b).length,
                b2c_available: mergedData.filter(c => c.available_in?.b2c).length,
              },
              hitBy: 'Cache+Incremental',
            };
            
            // Update React Query cache directly - this updates the cache in place without refetching
            // Create a completely new object reference to ensure React Query detects the change
            const queryKey = [...queryKeys.categories.all, 'withSubcategories', userType || 'all'];
            
            // Update the cache - this will trigger a re-render in all components using this query
            // Using setQueryData updates the cache in place, no refetch needed
            queryClient.setQueryData(queryKey, updatedResponse);
            
            console.log('âœ… [useCategories] Incremental update merged, saved, and React Query cache updated');
            console.log(`   ðŸ“Š Updated category names in cache: ${mergedData.map(c => c.name).join(', ')}`);
            
            // Return the updated response so the query result reflects the changes immediately
            return updatedResponse;
          } else {
            // No updates, return cached data from AsyncStorage
            return {
              status: 'success',
              msg: 'Categories with subcategories retrieved successfully (cached)',
              data: cachedData,
              meta: {
                total_categories: cachedData.length,
                total_subcategories: cachedData.reduce((sum, cat) => sum + cat.subcategory_count, 0),
                b2b_available: cachedData.filter(c => c.available_in.b2b).length,
                b2c_available: cachedData.filter(c => c.available_in.b2c).length,
              },
              hitBy: 'Cache',
            };
          }
        } catch (error) {
          // If incremental update fails, return cached data from AsyncStorage
          console.warn('Incremental update failed, using cached data:', error);
          return {
            status: 'success',
            msg: 'Categories with subcategories retrieved successfully (cached, update failed)',
            data: cachedData,
            meta: {
              total_categories: cachedData.length,
              total_subcategories: cachedData.reduce((sum, cat) => sum + cat.subcategory_count, 0),
              b2b_available: cachedData.filter(c => c.available_in.b2b).length,
              b2c_available: cachedData.filter(c => c.available_in.b2c).length,
            },
            hitBy: 'Cache',
          };
        }
      } else {
        // No cache or cache expired, fetch all data from API
        const response = await getCategoriesWithSubcategories(userType);
        
        // Save to AsyncStorage (365-day persistence)
        const currentTimestamp = new Date().toISOString();
        await saveCachedCategories(response.data, currentTimestamp);
        
        return {
          ...response,
          hitBy: 'API',
        };
      }
    },
    enabled,
    // Always refetch on mount to check for incremental updates
    // Even with 365-day staleTime, we want to check for updates on each dashboard load
    refetchOnMount: true,
    refetchOnWindowFocus: false,
    refetchOnReconnect: true,
    // 365-day cache configuration for React Query
    staleTime: 365 * 24 * 60 * 60 * 1000, // 365 days - data is considered fresh for 365 days
    gcTime: 365 * 24 * 60 * 60 * 1000, // 365 days - keep in React Query cache for 365 days
    // React Query will persist this to AsyncStorage via PersistQueryClientProvider
    // This ensures data survives app restarts for 365 days
    // The custom AsyncStorage cache (categoriesCache.ts) handles incremental updates
    placeholderData: async () => {
      // Return cached data immediately while fetching (if available)
      const cached = await getCachedCategories();
      if (cached) {
        return {
          status: 'success',
          msg: 'Loading from cache...',
          data: cached,
          meta: {
            total_categories: cached.length,
            total_subcategories: cached.reduce((sum, cat) => sum + cat.subcategory_count, 0),
            b2b_available: cached.filter(c => c.available_in.b2b).length,
            b2c_available: cached.filter(c => c.available_in.b2c).length,
          },
          hitBy: 'Cache',
        };
      }
      return undefined;
    },
  });
};

/**
 * Hook to get user's operating categories
 */
export const useUserCategories = (
  userId: string | number | null | undefined,
  enabled = true
) => {
  return useApiQuery({
    queryKey: queryKeys.userCategories.byUser(userId!),
    queryFn: () => getUserCategories(userId!),
    enabled: enabled && !!userId,
    staleTime: 2 * 60 * 1000, // 2 minutes
    gcTime: 5 * 60 * 1000, // 5 minutes
    refetchOnMount: true, // Always refetch when component mounts
    refetchOnWindowFocus: true, // Refetch when window regains focus
  });
};

/**
 * Hook to get user's operating subcategories
 */
export const useUserSubcategories = (
  userId: string | number | null | undefined,
  enabled = true
) => {
  return useApiQuery({
    queryKey: queryKeys.userSubcategories.byUser(userId!),
    queryFn: () => getUserSubcategories(userId!),
    enabled: enabled && !!userId,
    staleTime: 2 * 60 * 1000, // 2 minutes
    gcTime: 5 * 60 * 1000, // 5 minutes
    refetchOnMount: true, // Always refetch when component mounts
    refetchOnWindowFocus: true, // Refetch when window regains focus
  });
};

/**
 * Hook to update user's operating categories
 */
export const useUpdateUserCategories = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (categoryIds: number[]) => updateUserCategories(userId, categoryIds),
    invalidateQueries: [
      ['userCategories'],
      ['categories'],
    ],
  });
};

/**
 * Hook to update user's operating subcategories
 */
export const useUpdateUserSubcategories = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (subcategories: Array<{ subcategoryId: number; customPrice: string; priceUnit: string }>) => 
      updateUserSubcategories(userId, subcategories),
    invalidateQueries: [
      queryKeys.userSubcategories.byUser(userId),
      queryKeys.userCategories.byUser(userId),
    ],
  });
};

/**
 * Hook to remove a category and all its subcategories
 */
export const useRemoveUserCategory = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (categoryId: string | number) => 
      removeUserCategory(userId, categoryId),
    invalidateQueries: [
      queryKeys.userSubcategories.byUser(userId),
      queryKeys.userCategories.byUser(userId),
    ],
  });
};

/**
 * Hook to remove specific subcategories
 */
export const useRemoveUserSubcategories = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (subcategoryIds: number[]) => 
      removeUserSubcategories(userId, subcategoryIds),
    invalidateQueries: [
      queryKeys.userSubcategories.byUser(userId),
      queryKeys.userCategories.byUser(userId),
    ],
  });
};

      } else {
        // No cache or cache expired, fetch all data from API
        const response = await getCategoriesWithSubcategories(userType);
        
        // Save to AsyncStorage (365-day persistence)
        const currentTimestamp = new Date().toISOString();
        await saveCachedCategories(response.data, currentTimestamp);
        
        return {
          ...response,
          hitBy: 'API',
        };
      }
    },
    enabled,
    // Always refetch on mount to check for incremental updates
    // Even with 365-day staleTime, we want to check for updates on each dashboard load
    refetchOnMount: true,
    refetchOnWindowFocus: false,
    refetchOnReconnect: true,
    // 365-day cache configuration for React Query
    staleTime: 365 * 24 * 60 * 60 * 1000, // 365 days - data is considered fresh for 365 days
    gcTime: 365 * 24 * 60 * 60 * 1000, // 365 days - keep in React Query cache for 365 days
    // React Query will persist this to AsyncStorage via PersistQueryClientProvider
    // This ensures data survives app restarts for 365 days
    // The custom AsyncStorage cache (categoriesCache.ts) handles incremental updates
    placeholderData: async () => {
      // Return cached data immediately while fetching (if available)
      const cached = await getCachedCategories();
      if (cached) {
        return {
          status: 'success',
          msg: 'Loading from cache...',
          data: cached,
          meta: {
            total_categories: cached.length,
            total_subcategories: cached.reduce((sum, cat) => sum + cat.subcategory_count, 0),
            b2b_available: cached.filter(c => c.available_in.b2b).length,
            b2c_available: cached.filter(c => c.available_in.b2c).length,
          },
          hitBy: 'Cache',
        };
      }
      return undefined;
    },
  });
};

/**
 * Hook to get user's operating categories
 */
export const useUserCategories = (
  userId: string | number | null | undefined,
  enabled = true
) => {
  return useApiQuery({
    queryKey: queryKeys.userCategories.byUser(userId!),
    queryFn: () => getUserCategories(userId!),
    enabled: enabled && !!userId,
    staleTime: 2 * 60 * 1000, // 2 minutes
    gcTime: 5 * 60 * 1000, // 5 minutes
    refetchOnMount: true, // Always refetch when component mounts
    refetchOnWindowFocus: true, // Refetch when window regains focus
  });
};

/**
 * Hook to get user's operating subcategories
 */
export const useUserSubcategories = (
  userId: string | number | null | undefined,
  enabled = true
) => {
  return useApiQuery({
    queryKey: queryKeys.userSubcategories.byUser(userId!),
    queryFn: () => getUserSubcategories(userId!),
    enabled: enabled && !!userId,
    staleTime: 2 * 60 * 1000, // 2 minutes
    gcTime: 5 * 60 * 1000, // 5 minutes
    refetchOnMount: true, // Always refetch when component mounts
    refetchOnWindowFocus: true, // Refetch when window regains focus
  });
};

/**
 * Hook to update user's operating categories
 */
export const useUpdateUserCategories = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (categoryIds: number[]) => updateUserCategories(userId, categoryIds),
    invalidateQueries: [
      ['userCategories'],
      ['categories'],
    ],
  });
};

/**
 * Hook to update user's operating subcategories
 */
export const useUpdateUserSubcategories = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (subcategories: Array<{ subcategoryId: number; customPrice: string; priceUnit: string }>) => 
      updateUserSubcategories(userId, subcategories),
    invalidateQueries: [
      queryKeys.userSubcategories.byUser(userId),
      queryKeys.userCategories.byUser(userId),
    ],
  });
};

/**
 * Hook to remove a category and all its subcategories
 */
export const useRemoveUserCategory = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (categoryId: string | number) => 
      removeUserCategory(userId, categoryId),
    invalidateQueries: [
      queryKeys.userSubcategories.byUser(userId),
      queryKeys.userCategories.byUser(userId),
    ],
  });
};

/**
 * Hook to remove specific subcategories
 */
export const useRemoveUserSubcategories = (userId: string | number) => {
  return useApiMutation({
    mutationFn: (subcategoryIds: number[]) => 
      removeUserSubcategories(userId, subcategoryIds),
    invalidateQueries: [
      queryKeys.userSubcategories.byUser(userId),
      queryKeys.userCategories.byUser(userId),
    ],
  });
};
